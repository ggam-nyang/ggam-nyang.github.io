{"componentChunkName":"component---src-templates-blog-template-js","path":"/c++/VirtualFunction/","result":{"data":{"cur":{"id":"44c5e6e7-e5b4-563f-bdc1-20d32f896828","html":"<h1 id=\"가상-함수\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%ED%95%A8%EC%88%98\" aria-label=\"가상 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 함수</h1>\n<p><a href=\"https://www.geeksforgeeks.org/difference-between-virtual-function-and-pure-virtual-function-in-c/\">가상 함수 vs 순수 가상 함수</a><br>\n<a href=\"https://tcpschool.com/cpp/cpp_polymorphism_virtual\">가상 함수 한글자료</a><br>\n<a href=\"https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-cpp/\">가상 함수 런타임</a></p>\n<h3 id=\"가상-함수-1\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%ED%95%A8%EC%88%98-1\" aria-label=\"가상 함수 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 함수</h3>\n<p>가상 함수는 클래스 멤버 변수에 선언할 수 있고, 함수 호출에 사용된 타입(포인터)에 관계없이 실제 객체의 함수가 호출되도록 한다.\n몇 가지 특징, 규칙은 아래와 같다.</p>\n<ul>\n<li>런타임 다형성을 구현할 수 있다.\n<ul>\n<li>이를 위해 상위 클래스 타입을 사용해야한다.</li>\n</ul>\n</li>\n<li>가상 함수는 하위 클래스에서 꼭 override 해야하는 것은 아니다.</li>\n<li>가상 함수의 시그니처는 동일해야한다.</li>\n<li>가상 생성자는 불가능하다. 소멸자는 가능</li>\n</ul>\n<p>어떻게 이런 동작을 할까?</p>\n<ul>\n<li>RTTI(RunTime Type Information)을 활용한다.</li>\n<li>클래스와 객체를 생성할 때 각각 VTable, VPtr이 생성된다.</li>\n</ul>\n<p>아래 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass base {\npublic:\n\tvirtual void print() { cout &lt;&lt; &quot;print base class\\\\n&quot;; }\n\n\tvoid show() { cout &lt;&lt; &quot;show base class\\\\n&quot;; }\n};\n\nclass derived : public base {\npublic:\n\tvoid print() { cout &lt;&lt; &quot;print derived class\\\\n&quot;; }\n\n\tvoid show() { cout &lt;&lt; &quot;show derived class\\\\n&quot;; }\n};\n\nint main()\n{\n\tbase* bptr;\n\tderived d;\n\tbptr = &amp;d;\n\n\tbptr-&gt;print(); // derived.print()\n\n\tbptr-&gt;show(); // base.show()\n\n\treturn 0;\n}\n</code></pre></div>\n<p>각 <code class=\"language-text\">bptr = &amp;d</code> 에서 실제 derived 객체를 생성하고, 타입은 base 포인터이다.\n이때 derived 객체는 멤버 변수로만 이뤄지지 않고, VPtr이라는 주소값이 할당된다.\n이 VPtr은 실제 이 객체의 가상 함수 테이블(VTable)을 가르킨다.</p>\n<p>이렇게 함수를 호출할 때 어느 블록(테이블)에 있는 함수를 실행할지 결정하는 것을 바인딩이라고 한다.<br>\n대부분 함수를 호출하는 코드는 컴파일 시점에 고정된 메모리 주소로 변환된다.<br>\n이를 <strong>정적 바인딩</strong>이라 하고, 위와 같은 경우를 <strong>동적 바인딩</strong>이라 한다.</p>\n<p>때문에 런타임에 *bptr 객체는 실제 어떤 함수를 호출해야 하는지 알 수 있다.</p>\n<h3 id=\"순수-가상-함수\" style=\"position:relative;\"><a href=\"#%EC%88%9C%EC%88%98-%EA%B0%80%EC%83%81-%ED%95%A8%EC%88%98\" aria-label=\"순수 가상 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순수 가상 함수</h3>\n<p>순수 가상 함수는 <code class=\"language-text\">virtual void func() = 0</code> 과 같이 구현한다.\n이와 같은 순수 가상 함수가 1개 이상 포함된 클래스는 추상 클래스가 된다.\n때문에 객체를 생성할 수 없고, 하위 클래스는 해당 함수를 반드시 구현해야한다. (아니라면 마찬가지로 추상 클래스)\n자바의 interface를 이용해 유연한 설계를 한다면, 순수 가상 함수를 섞어 interface 역할의 클래스를 생성할 수 있을 것이다.</p>","excerpt":"가상 함수 가상 함수 vs 순수 가상 함수 가상 함수 한글자료 가상 함수 런타임 가상 함수 가상 함수는 클래스 멤버 변수에 선언할 수 있고, 함수 호출에 사용된 타입(포인터)에 관계없이 실제 객체의 함수가 호출되도록 한다.\n몇 가지 특징, 규칙은 아래와 같다. 런타임 다형성을 구현할 수 있다. 이를 위해 상위 클래스 타입을 사용해야한다. 가상 함수는 하위 클래스에서 꼭 override 해야하는 것은 아니다. 가상 함수의 시그니처는 동일해야한다. 가상 생성자는 불가능하다. 소멸자는 가능 어떻게 이런 동작을 할까? RTTI(RunTime Type Information)을 활용한다. 클래스와 객체를 생성할 때 각각 VTable, VPtr이 생성된다. 아래 예시를 보자. 각  에서 실제 derived 객체를 생성하고, 타입은 base 포인터이다.\n이때 derived 객체는 멤버 변수로만 이뤄지지 않고, VPtr이라는 주소값이 할당된다.\n이 VPtr은 실제 이 객체의 가상 함수 테이블(VT…","frontmatter":{"date":"January 30, 2024","title":"c++의 가상 함수란!","categories":"C++","author":"지구깜냥","emoji":"✏️"},"fields":{"slug":"/c++/VirtualFunction/"}},"next":{"id":"6cb8c85c-b1db-527d-9f59-e24867c093df","html":"<h2 id=\"-mac-parallels\" style=\"position:relative;\"><a href=\"#-mac-parallels\" aria-label=\" mac parallels permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💻 Mac Parallels</h2>\n<p>맥북에서 parallels를 이용해, Window를 설치했다.</p>\n<p>Window 환경에서 개발을 진행하기 위해서 설치했고, 가상머신 위에서 얼마나 쾌적할지 걱정했지만 사용성이 괜찮았다.<br>\n물론 아직 규모 있는 프로젝트를 진행하진 않아서 문제가 없었지만, 성능이 더 요구되면 어려울 수도 있다.</p>\n<p>문제는 Parallels 위에서 Visual Studio 2022를 사용할 때 발생했다.<br>\nVS도 Extension이 있는데, 대부분의 extension을 설치할 수 없었다.<br>\n여러 시도를 한 끝에 이런 환경에서 설치하는 방법을 남겨 놓는다!</p>\n<h2 id=\"vsix-파일-수정\" style=\"position:relative;\"><a href=\"#vsix-%ED%8C%8C%EC%9D%BC-%EC%88%98%EC%A0%95\" aria-label=\"vsix 파일 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VSIX 파일 수정</h2>\n<p><a href=\"https://marketplace.visualstudio.com/vs\">vs marketplace</a>에 들어가보면 다양한 extension을 볼 수 있다.<br>\nvsix 파일을 설치해서 실행하면, 설치 할 수 있는 버전을 찾을 수 없다고 나온다.<br>\n이상하게 IDE 내에서 검색되는 extension과 웹에 있는게 달랐는데, 결과적으로 각 extension마다 지원하는 버전과 프로세서가 다르기 때문이다.</p>\n<p>Mac M1은 arm64 칩을 사용한다. 컴퓨터 하드웨어를 잘 모르지만, Window 생태계에서는 대부분 intel 혹은 Arm 칩을 사용하는 것으로 안다.\n때문에 대부분의 Extension들이 Arm64를 지원하지 않았다. (<strong>amd64와 헷갈렸다…</strong>)</p>\n<p>그래서 <a href=\"https://www.bytehide.com/blog/visual-studio-2022-extensions\">VS extension top 10</a>의 대부분을 사용할 수 없다.</p>\n<p>marketplace에서 extension을 설치하면 .vsix 확장자의 파일이 설치된다.<br>\n7-zip (혹은 다른 zip 관련 프로그램)을 설치 후!<br>\n해당 파일에 대해 아래와 같이 진행한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAB2HAAAdhwGP5fFlAAABwElEQVQoz11SibLaMBDL//9cDxgYCoQkQE7nsh07B6COtoWXNjMax+u1tFpvEKcK20ghbRwSNaAcXoLCPgW5XhA3I86VR9TMSPoXQjUiVF7Wq34hah9Iuwn8gk5bxJXBt18hvv/Y4JYV0NbD+klg3IjazlB2QeOeaEegMrOAe/LUXN3yh9AZBd0p5GWJ2/WKPMtgjcY8TfDOwbkBfrDQXQureyzTCKM7wWOZ8HosGP2AwRosy4Kg6zpkZY3jNUcSx0jTVJBlGYwxsHaAsRa73Q7b7Ra91nDewzkHa61gGAYB84PHskAbizQvsdn8xPF4hNZaEsZxxMRKvcfpdML5fEbf9xJnjGdrMB7MMy84tG2DOI5FeZ7nTxIvEnmeI4oiWYuiQFmWH5I1Al7u+w73+x1hGKJpmo/6usLD4SCWScjYWvSfCqd5EoskSpJE1Gn3neD/9ouW9/u9tIT9ZYXM49m6gGC0DoMxUEqJJQap/rbwtlxVFW63mxCxSrphjPu2bb8In1bBtBWapkVZFPJSVP2/P5fLRWyzzwTF6Yao6/qLsKwbeWWlakmiIl9yXSVFaJMuOCZsEXM4cgT/GefY/AZ0U0XxGXCHKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vsix 압축 열기\"\n        title=\"vsix 압축 열기\"\n        src=\"/static/a5a45f84049860e2fe25dc2aae7bcdd2/37523/7-zip-pic.png\"\n        srcset=\"/static/a5a45f84049860e2fe25dc2aae7bcdd2/e9ff0/7-zip-pic.png 180w,\n/static/a5a45f84049860e2fe25dc2aae7bcdd2/f21e7/7-zip-pic.png 360w,\n/static/a5a45f84049860e2fe25dc2aae7bcdd2/37523/7-zip-pic.png 720w,\n/static/a5a45f84049860e2fe25dc2aae7bcdd2/302a4/7-zip-pic.png 1080w,\n/static/a5a45f84049860e2fe25dc2aae7bcdd2/07a9c/7-zip-pic.png 1440w,\n/static/a5a45f84049860e2fe25dc2aae7bcdd2/e4ee8/7-zip-pic.png 1496w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n압축을 열고~</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAB2HAAAdhwGP5fFlAAABHUlEQVQoz3WSiW6DMAyGef83nLqSBDJycIi7hOuf7CmoXbdIlpGxP/92kiitkOsvWOtQGAPnPayx8M6i73s8Hg9M0/Ri8zxf/tkolnyKG6TMcE8F0jSFEBJSSOg8R13XaJoG4ziyDcPA1nXd5alp9AwsdIq+H1CVJYwxnLiuK9uyBIysZILW+oK3bYsQAgMIRupokn3fkWRZxmN2XYuiKDgpnvM82YewQEoJ5xyDCHgcBzel2PNJhEg5aK3hIlIQYRG4LAuElPDeY9s2Vkpq1jXwVPQda5Lbxx2+9CjLEqT2LyCNI4R4B4bAYkjtBZRCoaoqOGehlPpf4Rvw4EZ5nr8Ch+HnadCe4oX8BpIa2hvtl4qpAf0jONXEPAJ+AxACZp1OGKEQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"extension manifest 열기\"\n        title=\"extension manifest 열기\"\n        src=\"/static/74e725600848550d4191548ddc54a23b/37523/extension_archive.png\"\n        srcset=\"/static/74e725600848550d4191548ddc54a23b/e9ff0/extension_archive.png 180w,\n/static/74e725600848550d4191548ddc54a23b/f21e7/extension_archive.png 360w,\n/static/74e725600848550d4191548ddc54a23b/37523/extension_archive.png 720w,\n/static/74e725600848550d4191548ddc54a23b/302a4/extension_archive.png 1080w,\n/static/74e725600848550d4191548ddc54a23b/07a9c/extension_archive.png 1440w,\n/static/74e725600848550d4191548ddc54a23b/31d79/extension_archive.png 1954w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nextension manifest 파일을 편집한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAB2HAAAdhwGP5fFlAAABd0lEQVQoz2VT2XKDMBDj//8OCglkkmBuCJgjCeR6UEdbTKF90MhmjSztgpUkCU6nE+q6RtM00LoR5l6e6Z91WZa4XC6CqqowTRMej4fw6/VaYFVliSAIEEURlAqFwzCUS87nszBFeAmFdKuFeQmZtfv9jnEcRdzizbZtw3W/YDsOPM+D67o4Ho+LcBzHItC2LbTW6PoOfd9jGAYMff/7vOtg8SAdUsBARUqcRlEMtoSCcZJAKSWgK91oEXy/3xuIQ9f14Ps+9vu9gIJpmkJFEa7XK57Pp8RZ43a7SUzW1rCyLENwOMhtPESmdTJjmd5wAOvm0w2ZIpuh1PUFjuPAD3yJR2dkRqb7fu4RG29E1jCChq2iKLDb7eRlE4OgAPd0ZmBqEnuc/sUVQUbmdNl4rmUAM5J5EHRNcDB5niMvcmG25fP5bNxaLPCzSbMMbdstH3jbaonKPXtqwNrPD6AFPEPhxSEF6YIF9muDeTBmPcz4O3G2wwh+A97IPDYSzKrsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"manifest 내용\"\n        title=\"manifest 내용\"\n        src=\"/static/7d37d0d1cfc267f46a7a012cf27959d5/37523/extension_manifest_picture.png\"\n        srcset=\"/static/7d37d0d1cfc267f46a7a012cf27959d5/e9ff0/extension_manifest_picture.png 180w,\n/static/7d37d0d1cfc267f46a7a012cf27959d5/f21e7/extension_manifest_picture.png 360w,\n/static/7d37d0d1cfc267f46a7a012cf27959d5/37523/extension_manifest_picture.png 720w,\n/static/7d37d0d1cfc267f46a7a012cf27959d5/302a4/extension_manifest_picture.png 1080w,\n/static/7d37d0d1cfc267f46a7a012cf27959d5/07a9c/extension_manifest_picture.png 1440w,\n/static/7d37d0d1cfc267f46a7a012cf27959d5/5b503/extension_manifest_picture.png 1976w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n여기서 보면 IDE(vs)의 Target Version과 Architecture 등이 있다.<br>\n여기서 버전이 맞지 않다면 버전을, Arm64 환경에서 동작해야 한다면 Architecture를 변경해주면 vsix 파일이 잘 작동한다.</p>\n<p>물론 extension의 설정을 변경해서, 오작동하는 경우도 있을테지만 theme와 같은 extension들은 크게 충돌하지 않는 것 같다!</p>\n<p>때문에 Mac Parallels에서도 extension을 설치할 수 있었다!</p>","frontmatter":{"date":"January 16, 2024","title":"Mac Parallels에서 Visual Studio Extension 설치하기","categories":"IDE","author":"지구깜냥","emoji":"✏️"},"fields":{"slug":"/c++/vsExtension/"}},"prev":{"id":"e9e6520f-354b-5eb1-90ae-eba62aabec8c","html":"<h2 id=\"deque의-push_front-시간복잡도\" style=\"position:relative;\"><a href=\"#deque%EC%9D%98-push_front-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"deque의 push_front 시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>deque의 push_front 시간복잡도</h2>\n<p>list는 Node로 구성되어, 삽입 삭제에 유리하지만 operator [] 를 사용할 수 없다.\nvector는 데이터가 선형으로 이어져야 하기 때문에 삽입/삭제 시 불리하지만, operator []가 가능하다.\nc++ 표준 라이브러리가 제공하는 Deque는 이 둘을 섞은 느낌이다.\nDeque는 block의 형태로 구현되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">_NODISCARD const_reference operator[](size_type _Pos) const noexcept /* strengthened */ {\n#if _CONTAINER_DEBUG_LEVEL &gt; 0\n        _STL_VERIFY(_Pos &lt; _Mysize(), &quot;deque subscript out of range&quot;);\n#endif // _CONTAINER_DEBUG_LEVEL &gt; 0\n\n        return *(_Unchecked_begin() + static_cast&lt;difference_type&gt;(_Pos));\n    }\n\n_NODISCARD reference operator*() const noexcept {\n    _Size_type _Block = _Mycont-&gt;_Getblock(_Myoff);\n    _Size_type _Off   = _Myoff % _Block_size;\n    return _Mycont-&gt;_Map[_Block][_Off];\n}</code></pre></div>\n<p>operator [], *를 보면 Block과 Map이 나온다.\nDeque는 내부적으로 block으로 이루어져 있다. 이 block이 하나의 vector(배열)이고, 이 block들이 여러개로 구성되어 있다.\n때문에 원소의 삽입,삭제는 빠르게 이루어진다. vector처럼 원소를 재정렬할 필요가 없기 때문이다.\n또 vector와 같이 []도 사용가능하다.</p>\n<p>여기서 의문이 생겼는데, push_front를 실행할 경우, 새로운 block이 필요할 수 있다.\n이 경우 새로운 block을 어떻게 관리하면 시간복잡도가 O(1)일 수 있을까 궁금했다.</p>\n<p>위 operator*를 보면, <code class=\"language-text\">_Map[_Block][_Off]</code> 를 통해 원소를 가져온다.\nblock들을 map으로 관리하고, 이 block에 접근하여 offset에 해당하는 원소를 가져온다.</p>\n<p>push_front()를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">template &lt;class... _Tys&gt;\nvoid _Emplace_front_internal(_Tys&amp;&amp;... _Vals) {\n    if (_Myoff() % _Block_size == 0 &amp;&amp; _Mapsize() &lt;= (_Mysize() + _Block_size) / _Block_size) {\n        _Growmap(1);\n    }\n... 중략\n\nvoid _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2\n    static_assert(_Minimum_map_size &gt; 1, &quot;The _Xlen() test should always be performed.&quot;);\n\n    _Alpty _Almap(_Getal());\n    size_type _Newsize = _Mapsize() &gt; 0 ? _Mapsize() : 1;\n    while (_Newsize - _Mapsize() &lt; _Count || _Newsize &lt; _Minimum_map_size) {\n        // scale _Newsize to 2^N &gt;= _Mapsize() + _Count\n        if (max_size() / _Block_size - _Newsize &lt; _Newsize) {\n            _Xlen(); // result too long\n        }\n\n        _Newsize *= 2;\n    }\n\n    size_type _Myboff = _Myoff() / _Block_size;\n    _Mapptr _Newmap   = _Allocate_at_least_helper(_Almap, _Newsize);\n    _Mapptr _Myptr    = _Newmap + _Myboff;\n\n    _Count = _Newsize - _Mapsize();\n\n    _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end\n    if (_Myboff &lt;= _Count) { // increment greater than offset of initial block\n        _Myptr = _STD uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); // copy rest of old\n        _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); // clear suffix of new\n        _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); // clear prefix of new\n    } else { // increment not greater than offset of initial block\n        _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old\n        _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old\n        _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); // clear rest to initial block\n    }\n\n    if (_Map() != nullptr) {\n        _Destroy_range(_Map(), _Map() + _Mapsize());\n        _Almap.deallocate(_Map(), _Mapsize()); // free storage for old\n    }\n\n    _Map() = _Newmap; // point at new\n    _Mapsize() += _Count;\n}</code></pre></div>\n<p>새로운 block이 필요한 경우 Growmap을 호출한다.\n이 함수의 흐름은</p>\n<ol>\n<li>새로운 맵 크기 계산(2배씩 늘려감)</li>\n<li>새로운 맵에 기존 맵 복사</li>\n<li>복사되지 않은 영역은 초기화</li>\n<li>기존 맵 메모리 해제\nMap의 크기가 부족하다면, <code class=\"language-text\">newSize</code> 를 2배한다.</li>\n<li>deque의 map, mapSize 등을 수정</li>\n</ol>\n<p>여기서 새로운 기존 맵 복사를 보면, push_front 상황이라면 기존 map을 전부 복사해야 하므로, 시간복잡도가 O(n)이 된다!!</p>\n<p>때문에 push_front의 시간복잡도는 새로운 block이 생길 경우에는, O(n)이다.</p>","frontmatter":{"date":"January 30, 2024","title":"Deque push_front는 O(1)일까?","categories":"C++","author":"지구깜냥","emoji":"✏️"},"fields":{"slug":"/c++/DequePushFront/"}},"site":{"siteMetadata":{"siteUrl":"https://ggam-nyang.github.io","comments":{"utterances":{"repo":"ggam-nyang/ggam-nyang.github.io"}}}}},"pageContext":{"slug":"/c++/VirtualFunction/","nextSlug":"/c++/vsExtension/","prevSlug":"/c++/DequePushFront/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}