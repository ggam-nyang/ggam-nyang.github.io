{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/C++","result":{"pageContext":{"currentCategory":"C++","categories":["All","C++","IDE","Infra","Spring","Kotlin","개발","DevOps","Numble","블로그"],"edges":[{"node":{"id":"e9e6520f-354b-5eb1-90ae-eba62aabec8c","excerpt":"deque의 push_front 시간복잡도 list는 Node로 구성되어, 삽입 삭제에 유리하지만 operator [] 를 사용할 수 없다.\nvector는 데이터가 선형으로 이어져야 하기 때문에 삽입/삭제 시 불리하지만, operator []가 가능하다.\nc++ 표준 라이브러리가 제공하는 Deque는 이 둘을 섞은 느낌이다.\nDeque는 block의 형태로 구현되어 있다. operator [], *를 보면 Block과 Map이 나온다.\nDeque는 내부적으로 block으로 이루어져 있다. 이 block이 하나의 vector(배열)이고, 이 block들이 여러개로 구성되어 있다.\n때문에 원소의 삽입,삭제는 빠르게 이루어진다. vector처럼 원소를 재정렬할 필요가 없기 때문이다.\n또 vector와 같이 []도 사용가능하다. 여기서 의문이 생겼는데, push_front를 실행할 경우, 새로운 block이 필요할 수 있다.\n이 경우 새로운 block을 어떻게 관리하면 시간복잡도가 O(1…","fields":{"slug":"/c++/DequePushFront/"},"frontmatter":{"categories":"C++","title":"Deque push_front는 O(1)일까?","date":"January 30, 2024"}},"next":{"fields":{"slug":"/c++/VirtualFunction/"}},"previous":null},{"node":{"id":"44c5e6e7-e5b4-563f-bdc1-20d32f896828","excerpt":"가상 함수 가상 함수 vs 순수 가상 함수 가상 함수 한글자료 가상 함수 런타임 가상 함수 가상 함수는 클래스 멤버 변수에 선언할 수 있고, 함수 호출에 사용된 타입(포인터)에 관계없이 실제 객체의 함수가 호출되도록 한다.\n몇 가지 특징, 규칙은 아래와 같다. 런타임 다형성을 구현할 수 있다. 이를 위해 상위 클래스 타입을 사용해야한다. 가상 함수는 하위 클래스에서 꼭 override 해야하는 것은 아니다. 가상 함수의 시그니처는 동일해야한다. 가상 생성자는 불가능하다. 소멸자는 가능 어떻게 이런 동작을 할까? RTTI(RunTime Type Information)을 활용한다. 클래스와 객체를 생성할 때 각각 VTable, VPtr이 생성된다. 아래 예시를 보자. 각  에서 실제 derived 객체를 생성하고, 타입은 base 포인터이다.\n이때 derived 객체는 멤버 변수로만 이뤄지지 않고, VPtr이라는 주소값이 할당된다.\n이 VPtr은 실제 이 객체의 가상 함수 테이블(VT…","fields":{"slug":"/c++/VirtualFunction/"},"frontmatter":{"categories":"C++","title":"c++의 가상 함수란!","date":"January 30, 2024"}},"next":{"fields":{"slug":"/c++/vsExtension/"}},"previous":{"fields":{"slug":"/c++/DequePushFront/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}