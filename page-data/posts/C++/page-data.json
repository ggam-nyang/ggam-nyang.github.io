{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/C++","result":{"pageContext":{"currentCategory":"C++","categories":["All","C++","IDE","Infra","Spring","Kotlin","개발","DevOps","Numble","블로그"],"edges":[{"node":{"id":"e9e6520f-354b-5eb1-90ae-eba62aabec8c","excerpt":"deque의 push_front 시간복잡도 list는 Node로 구성되어, 삽입 삭제에 유리하지만 operator [] 를 사용할 수 없다.\nvector는 데이터가 선형으로 이어져야 하기 때문에 삽입/삭제 시 불리하지만, operator []가 가능하다.\nc++ 표준 라이브러리가 제공하는 Deque는 이 둘을 섞은 느낌이다.\nDeque는 block의 형태로 구현되어 있다. operator [], *를 보면 Block과 Map이 나온다.\nDeque는 내부적으로 block으로 이루어져 있다. 이 block이 하나의 vector(배열)이고, 이 block들이 여러개로 구성되어 있다.\n때문에 원소의 삽입,삭제는 빠르게 이루어진다. vector처럼 원소를 재정렬할 필요가 없기 때문이다.\n또 vector와 같이 []도 사용가능하다. 여기서 의문이 생겼는데, push_front를 실행할 경우, 새로운 block이 필요할 수 있다.\n이 경우 새로운 block을 어떻게 관리하면 시간복잡도가 O(1…","fields":{"slug":"/c++/DequePushFront/"},"frontmatter":{"categories":"C++","title":"Deque push_front는 O(1)일까?","date":"January 30, 2024"}},"next":{"fields":{"slug":"/c++/vsExtension/"}},"previous":null}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}