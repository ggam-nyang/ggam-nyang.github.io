{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Boost","result":{"pageContext":{"currentCategory":"Boost","categories":["All","C++","Boost","IDE","Infra","Spring","Kotlin","개발","DevOps","Numble","블로그"],"edges":[{"node":{"id":"e92e68b6-131b-5243-bde1-4ad8cb1e879e","excerpt":"클라이언트 스레드 관리 요약 클라이언트에서 전투 시작 시 콘솔 입력 + 패킷 처리가 동시에 실행이 되지 않았던 이유는\n콘솔 입력 작업을 중복으로 큐에 추가하여, 모든 스레드가 블로킹 됐기 때문이다. 문제 상황 boost asio를 이용해 소켓 프로그래밍을 구축했습니다.\n클라이언트의 스레드 구조는 아래와 같습니다. 4개의 작업스레드를 생성하고, io_context에 post된 작업을 스레드가 가져가서 작업을 하는 형태입니다. post 되는 작업은 Send() : 콘솔 입력 + 패킷 전송 Receive() : 패킷 수신 + 콘솔 출력 2개의 작업뿐입니다. 이해도 부족 처음 문제에 대해 다뤘던 문서 (읽어보지 않아도 됩니다..!) 요약 : 콘솔 입력 작업 / 패킷 수신 작업 2개의 작업이 존재하는데, 패킷 수신 작업이 1초마다 반복될 때, 두 작업이 동시에 진행되지 않았습니다. 정리했던 문서의 결과는 다음과 같습니다.\ngetline() 함수는 블로킹 함수이고, 이로 인해 다른 스레드에서…","fields":{"slug":"/c++/lobbyServer/ClientThread/"},"frontmatter":{"categories":"C++ Boost","title":"클라이언트 콘솔 입력 스레드 분리하기","date":"May 01, 2024"}},"next":{"fields":{"slug":"/c++/lobbyServer/Boost-Work/"}},"previous":null},{"node":{"id":"06f7f157-f0b3-5d74-885e-dbc3db2a7015","excerpt":"Boost asio::io_service::work 란? Boost asio를 사용해 소켓 서버를 생성하면, 항상 io_service(지금은 io_context로 대체)를 사용하게 된다. 링크에선 work를 사용해야 하는 이유를 다루고 있다. 두 코드를 보면, 1. thread 생성, 2. 작업 post,  두 개의 작업이 존재하고\n1번 코드는 1 → 2 (work 객체와 함께)\n2번 코드는 2 → 1 의 순서로 코드 흐름이 이어진다. post는 IO Execution Context(여기선 io_service)에서 실행하겠다는 의미이다.\n모든 context는 run을 실행해줘야 하는데, 여기선 thread를 생성하고  작업을 실행한다. 즉, 1번 코드는 IO Context run 이후 post\n2번 코드는 post 이후 IO Context를 run 한다. 즉, 남은 작업이 존재하지 않아도 io_service가 run을 반환하지 않도록 도와주는 것이 work의 역할이다. ps. De…","fields":{"slug":"/c++/lobbyServer/Boost-Work/"},"frontmatter":{"categories":"C++ Boost","title":"Boost Work란?","date":"March 23, 2024"}},"next":{"fields":{"slug":"/c++/lobbyServer/MemoryCycle/"}},"previous":{"fields":{"slug":"/c++/lobbyServer/ClientThread/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}