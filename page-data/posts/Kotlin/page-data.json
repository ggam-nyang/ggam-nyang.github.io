{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Kotlin","result":{"pageContext":{"currentCategory":"Kotlin","categories":["All","롱블랙","개발","데일리","DevOps","Numble","Kotlin","블로그"],"edges":[{"node":{"id":"1e048b5c-dfbc-598c-89c5-7536d03a22a7","excerpt":"Sealed Class 코틀린 sealed class 공식문서를 참고했습니다. 목적 클래스의 상속을 더 제어하기 위해 사용한다. 코틀린은 예약어를 통해 컴파일 과정에서 편의성을 제공하는 방식을 좋아하는 듯 하다. 이 구조에서, when 식의 else를 주목하자. 를 구현한 새로운 Class가 생긴다면, else문은 논리 오류가 될 수 있다.\n즉, 하위 클래스가 추가 됐을 때 컴파일러가 when이 모든 분기를 처리하는지 알 수 없다.\n또 새로운 클래스 처리를 잊어버려도 알 수 없다. 이 문제에 대한 해법이 이다. 를 상속하는 하위 클래스는 무조건 중첩 클래스로 구현되어야 한다.\nwhen식이 모든 하위 타입을 검사하는지 컴파일러는 알 수 있고, 새로운 클래스가 분기처리 되지 않으면 컴파일 오류가 난다. 는 그 자체로 abstract 하고, 인스턴스화 할 수 없다. 코틀린 1.5부터는 너무 많은 제약을 해소했다. 하위 클래스는 중첩 클래스가 아닌 가 정의된 패키지 안에서 구현할 수 있고…","fields":{"slug":"/열심히기록/Kotlin-In-Action/Sealed class/"},"frontmatter":{"categories":"Kotlin","title":"Sealed Class","date":"March 31, 2023"}},"next":{"fields":{"slug":"/꾸준히기록/daily/2023/03/31/"}},"previous":{"fields":{"slug":"/열심히기록/Numble-Deploy/호스트님 1차 세션/"}}},{"node":{"id":"193a618c-1423-5dfb-8033-7a6fa7a1e313","excerpt":"Kotlin-in-Action 5장 람다로 프로그래밍\n람다는 다른 함수에 넘길 수 있는 작은 코드 조각  리스트의 age가 가장 높은 원소를 찾는다면  두 변수가 필요하다. 람다를 활용한다면 코드 길이가 줄어든다. 마지막 줄을 개선해보자. \n함수의 마지막 인자가 람다 식이라면 중괄호로 뺄 수 있다. \n 람다가 유일한 인자고 괄호로 뺐다면 빈 괄호를 없앨 수 있다.\n 파라미터 타입을 명시하지 않고(컴파일러가 추론) 한개의 파라미터라면 더 코드를 줄인다.\n 자바 무명 클래스처럼 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의 앞에 선언된 로컬 변수까지 람다에서 사용할 수 있다. 람다 내부에서 변수 접근이 가능하고, 변경도 가능하다. 이런 변수를 람다가 포획한 변수라고 하는데, 어떤 함수가 로컬 변수를 포획한 람다를 반환 or 변수에 저장한다면 포획된 로컬 변수의 생명주기와 함수의 생명주기가 달라 질 수 있다. 이 함수는 항상 0을 반환한다.\nonclick 핸들러가 가 …","fields":{"slug":"/열심히기록/Kotlin-In-Action/5장 끄적이기/"},"frontmatter":{"categories":"Kotlin","title":"Kotlin-in-Action 5장","date":"March 25, 2023"}},"next":{"fields":{"slug":"/꾸준히기록/daily/2023/03/25/"}},"previous":{"fields":{"slug":"/꾸준히기록/daily/2023/03/27/"}}},{"node":{"id":"50c7061e-1924-505a-8af7-03cd1f79ea67","excerpt":"중복되는 내용이지만 Kotlin in Action 1,2,3,4장 정리를 모아놓았습니다. Kotlin 1장 코틀린의 빌더 패턴이란, 디자인 패턴 빌더 패턴과 같다. (p.44)\n 이처럼 Builder를 만들어 사용하는데, 파라미터가 명시적이고 필수 파라미터를 확인할 수 있다.\n외에도 여러 이점이 있어 Lombok에서도 지원하는 패턴인데\n코틀린의 경우, 생성자에 변수 명을 명시할 수 있고, 매개변수별로 기본값을 가질 수 있다.\n때문에 이 자체로 빌더 패턴이 구현되어 있어 이를 용이하게 사용하면 좋다. 1장은 코틀린의 주요 특성인 다양한 플랫폼, 정적 타입 언어, 함수형 + 객체 지향, 무료 오픈소스 대해 말한다. 코틀린의 철학 실용성 간결성 안전성 상호운용성 2장 대입문은 자바에서 식, 코틀린에서는 문이다. 코틀린에서는 와 같이 사용할 수 없다. 모든 변수를 val 선언, 변경이 불가피할때만 var 이용하자. 자바의 문자열 접합 연산은 내부적으로 를 사용해 효율적이다. 코틀린의 문자…","fields":{"slug":"/열심히기록/Kotlin-In-Action/1234/"},"frontmatter":{"categories":"Kotlin","title":"Kotlin-in-Action 1 ~ 4장","date":"March 24, 2023"}},"next":{"fields":{"slug":"/꾸준히기록/daily/2023/03/24/"}},"previous":{"fields":{"slug":"/꾸준히기록/daily/2023/03/25/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}