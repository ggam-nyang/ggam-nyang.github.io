{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Kotlin","result":{"pageContext":{"currentCategory":"Kotlin","categories":["All","Kotlin","데일리","롱블랙","개발","DevOps","Numble","블로그"],"edges":[{"node":{"id":"48549a88-0c64-5910-b7b5-07ac5b26b1ef","excerpt":"NextStep - TDD, 클린 코드 with Kotlin강의를 참고했습니다. Java, Kotlin의 Int 두 테스트는 모두 참일까?\n당연하게도 그렇다. 코틀린은 타입 추론을 통해, 타입을 명시하지 않아도 number1, number2는 Int가 된다.\n여기서 Int는 코틀린의 Primitive type이고 컴파일 된 바이트 코드를 자바를 역컴파일하면 int가 된다. 위 경우를 보자.\n결과는 테스트2만 통과한다. 이유가 뭘까?\n정답은  메서드와 자바의 Integer에 있다. isSameAs 메서드는 Object로 파라미터를 받는다. 그래서 Test1을 컴파일 후 자바로 디컴파일 해보면 위와 같다. isSameAs에 int를 넘길 순 없기에 원시타입 int의 래퍼 클래스인 Integer로 변환한다.\n때문에 지만 이 된다. 다음 테스트를 보자 위 테스트는 어떨까? 마찬가지로 동등성 비교는 통과하지만, 주소값을 비교하는 동일성 비교는 실패할까?\n정답은 모두 통과한다. 이유는 Int…","fields":{"slug":"/passion/Kotlin/value-class/"},"frontmatter":{"categories":"Kotlin","title":"Value Class","date":"June 29, 2023"}},"next":{"fields":{"slug":"/steady/daily/2023/06/28/"}},"previous":null},{"node":{"id":"c3418f11-70ed-54d9-b826-c3b3a13cb0b0","excerpt":"Sealed Class 코틀린 sealed class 공식문서를 참고했습니다. 목적 클래스의 상속을 더 제어하기 위해 사용한다. 코틀린은 예약어를 통해 컴파일 과정에서 편의성을 제공하는 방식을 좋아하는 듯 하다. 이 구조에서, when 식의 else를 주목하자. 를 구현한 새로운 Class가 생긴다면, else문은 논리 오류가 될 수 있다.\n즉, 하위 클래스가 추가 됐을 때 컴파일러가 when이 모든 분기를 처리하는지 알 수 없다.\n또 새로운 클래스 처리를 잊어버려도 알 수 없다. 이 문제에 대한 해법이 이다. 를 상속하는 하위 클래스는 무조건 중첩 클래스로 구현되어야 한다.\nwhen식이 모든 하위 타입을 검사하는지 컴파일러는 알 수 있고, 새로운 클래스가 분기처리 되지 않으면 컴파일 오류가 난다. 는 그 자체로 abstract 하고, 인스턴스화 할 수 없다. 코틀린 1.5부터는 너무 많은 제약을 해소했다. 하위 클래스는 중첩 클래스가 아닌 가 정의된 패키지 안에서 구현할 수 있고…","fields":{"slug":"/passion/Kotlin-In-Action/Sealed class/"},"frontmatter":{"categories":"Kotlin","title":"Sealed Class","date":"March 31, 2023"}},"next":{"fields":{"slug":"/steady/daily/2023/03/30/"}},"previous":{"fields":{"slug":"/passion/Numble-Deploy/호스트님 1차 세션/"}}},{"node":{"id":"74599883-6278-58d8-bf69-4dcbd085f50b","excerpt":"Kotlin-in-Action 5장 람다로 프로그래밍\n람다는 다른 함수에 넘길 수 있는 작은 코드 조각  리스트의 age가 가장 높은 원소를 찾는다면  두 변수가 필요하다. 람다를 활용한다면 코드 길이가 줄어든다. 마지막 줄을 개선해보자. \n함수의 마지막 인자가 람다 식이라면 중괄호로 뺄 수 있다. \n 람다가 유일한 인자고 괄호로 뺐다면 빈 괄호를 없앨 수 있다.\n 파라미터 타입을 명시하지 않고(컴파일러가 추론) 한개의 파라미터라면 더 코드를 줄인다.\n 자바 무명 클래스처럼 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의 앞에 선언된 로컬 변수까지 람다에서 사용할 수 있다. 람다 내부에서 변수 접근이 가능하고, 변경도 가능하다. 이런 변수를 람다가 포획한 변수라고 하는데, 어떤 함수가 로컬 변수를 포획한 람다를 반환 or 변수에 저장한다면 포획된 로컬 변수의 생명주기와 함수의 생명주기가 달라 질 수 있다. 이 함수는 항상 0을 반환한다.\nonclick 핸들러가 가 …","fields":{"slug":"/passion/Kotlin-In-Action/5장 끄적이기/"},"frontmatter":{"categories":"Kotlin","title":"Kotlin-in-Action 5장","date":"March 25, 2023"}},"next":{"fields":{"slug":"/steady/daily/2023/03/24/"}},"previous":{"fields":{"slug":"/steady/daily/2023/03/25/"}}},{"node":{"id":"c4c4952b-eac3-5468-820b-68647b0b512c","excerpt":"중복되는 내용이지만 Kotlin in Action 1,2,3,4장 정리를 모아놓았습니다. Kotlin 1장 코틀린의 빌더 패턴이란, 디자인 패턴 빌더 패턴과 같다. (p.44)\n 이처럼 Builder를 만들어 사용하는데, 파라미터가 명시적이고 필수 파라미터를 확인할 수 있다.\n외에도 여러 이점이 있어 Lombok에서도 지원하는 패턴인데\n코틀린의 경우, 생성자에 변수 명을 명시할 수 있고, 매개변수별로 기본값을 가질 수 있다.\n때문에 이 자체로 빌더 패턴이 구현되어 있어 이를 용이하게 사용하면 좋다. 1장은 코틀린의 주요 특성인 다양한 플랫폼, 정적 타입 언어, 함수형 + 객체 지향, 무료 오픈소스 대해 말한다. 코틀린의 철학 실용성 간결성 안전성 상호운용성 2장 대입문은 자바에서 식, 코틀린에서는 문이다. 코틀린에서는 와 같이 사용할 수 없다. 모든 변수를 val 선언, 변경이 불가피할때만 var 이용하자. 자바의 문자열 접합 연산은 내부적으로 를 사용해 효율적이다. 코틀린의 문자…","fields":{"slug":"/passion/Kotlin-In-Action/1234/"},"frontmatter":{"categories":"Kotlin","title":"Kotlin-in-Action 1 ~ 4장","date":"March 24, 2023"}},"next":{"fields":{"slug":"/steady/daily/2023/03/23/"}},"previous":{"fields":{"slug":"/steady/daily/2023/03/24/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}